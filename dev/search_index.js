var documenterSearchIndex = {"docs":
[{"location":"struct/#scatteringTransform-type","page":"scatteringTransform type","title":"scatteringTransform type","text":"","category":"section"},{"location":"struct/","page":"scatteringTransform type","title":"scatteringTransform type","text":"scatteringTransform\nscatteringTransform(inputSize, m, backend::UnionAll; kwargs...)\nstFlux","category":"page"},{"location":"struct/#ScatteringTransform.scatteringTransform","page":"scatteringTransform type","title":"ScatteringTransform.scatteringTransform","text":"scatteringTransform{Dimension,Depth}\n\nThe abstract type and constructor for scattering transforms. The specific types are stFlux in this package, and stParallel in ParallelScattering.jl.\n\n\n\n\n\n","category":"type"},{"location":"struct/#ScatteringTransform.scatteringTransform-Tuple{Any, Any, UnionAll}","page":"scatteringTransform type","title":"ScatteringTransform.scatteringTransform","text":"scatteringTransform(inputSize, m=2, backend::UnionAll=stFlux; kwargs...)\n\nThe constructor for the abstract type scatteringTransform, with the concrete type specified by backend.\n\n\n\n\n\n","category":"method"},{"location":"struct/#ScatteringTransform.stFlux","page":"scatteringTransform type","title":"ScatteringTransform.stFlux","text":"stFlux(inputSize::NTuple{N}, m=2; trainable=false,\n                         normalize=true, outputPool=2,\n                         poolBy=3 // 2, σ=abs, flatten=false, kwargs...)\n\nCreate a scattering transform of depth m (which returns a m+1 depth list of arrays stored in a ScatteredOut) that subsamples at a rate of poolBy each layer, using scales[i] and shearLevels[i] at each layer. normalize means give each layer the same average weight per path, e.g. since the zeroth layer has one path, give it norm 1, if the first layer has 16 paths, give the sum across all first layer paths norm 16, etc. This is primarily for cases where the classification algorithm needs roughly the same order of magnitude variance. flatten means return a result that is a matrix of size (:,nExamples) where nExamples is the last dimension of inputSize. σ is the nonlinearity used. Any additional keyword args kwargs... come from either the FourierFilterFlux waveletLayerConstructor, or subsequently from ContinuousWavlets wavelet constructor ContinuousWavelets.\n\nExamples\n\njulia> using ScatteringTransform\n\njulia> x = [ones(128); zeros(128)];\n\njulia> St = stFlux((256,1,1))\n┌ Warning: there are wavelets whose peaks are far enough apart that the trough between them is less than half the height of the highest frequency wavelet\n│   minimalRegionComparedToLastPeak = 2.45709167339886\n└ @ ContinuousWavelets ~/allHail/projects/ContinuousWavelets/src/sanityChecks.jl:28\n┌ Warning: there are wavelets whose peaks are far enough apart that the trough between them is less than half the height of the highest frequency wavelet\n│   minimalRegionComparedToLastPeak = 2.5356674293941244\n└ @ ContinuousWavelets ~/allHail/projects/ContinuousWavelets/src/sanityChecks.jl:28\n┌ Warning: there are wavelets whose peaks are far enough apart that the trough between them is less than half the height of the highest frequency wavelet\n│   minimalRegionComparedToLastPeak = 2.2954419414285616\n└ @ ContinuousWavelets ~/allHail/projects/ContinuousWavelets/src/sanityChecks.jl:28\nstFlux{2, Nd=1, filters=[12], σ = abs, batchSize = 1, normalize = true}\n\njulia> St(x)\nScatteredOut{Array{Float32},3} 1 dim. OutputSizes:\n    (128, 1, 1)\n    (86, 12, 1)\n    (57, 11, 12, 1)\n\n\n\n\n\n\n","category":"type"},{"location":"struct/#Parameters-unique-to-ScatteringTransform.jl","page":"scatteringTransform type","title":"Parameters unique to ScatteringTransform.jl","text":"","category":"section"},{"location":"struct/","page":"scatteringTransform type","title":"scatteringTransform type","text":"m::Integer=2: the total number of layers\nnormalize::Bool=true: if true, apply the function normalize. The amount of energy in each layer decays exponentially for most inputs, so without normalizing, using the scattering coefficients poses some difficulty. To avoid this, when normalize is true, each layer is divided by the overall norm of that layer, and then multiplied by the number of paths in that layer.\npoolBy::Union{<:Integer, <:Rational, <:Tuple}=3//2: the amount to pool between layers. For a two layer network, the default is expanded to (3//2, 3//2, 3//2), corresponding to the first layer, second layer, and final averaging subsampling rates. It also accepts tuples that are too short, and simply replicates the last entry, e.g. poolBy=(2,3//2) for a three layer network is equivalent to poolBy=(2,3//2,3//2,3//2).\noutputPool::Union{<:Integer, <:Rational, <:Tuple}=2: the amount to subsample after averaging in each layer (present because averaging removes the high frequencies, so the full signal is inherently redundant). Has a similar structure to poolBy.\nflatten::Bool=false: if true, return a matrix that is (nCoefficients,nExamples), otherwise, return the more structured ScatteredOut\nσ::function=abs: the nonlinearity applied pointwise between layers. This should take in a Number, and return a Number (real or complex floating point). If the wavelet transform is analytic, this must have a method for Complex.","category":"page"},{"location":"struct/#Parameters-passed-to-[FourierFilterFlux.jl](https://dsweber2.github.io/FourierFilterFlux.jl/dev/)","page":"scatteringTransform type","title":"Parameters passed to FourierFilterFlux.jl","text":"","category":"section"},{"location":"struct/","page":"scatteringTransform type","title":"scatteringTransform type","text":"dtype::DataType=Float32: the data type used to represent the filters.\ncw::ContWaveClass=Morlet(): the type of wavelet to use.\nplan::Bool=true: if true, store the fft plan for reuse.\nconvBoundary::ConvBoundary=Sym(): the type of symmetry to use in computing the transform. Note that convBoundary and boundary are different, with boundary needing to be set using types from ContinuousWavelets and convBoundary needs to be set using the FourierFilterFlux types.\naveragingLayer::Bool=false: if true, use just the averaging filter, and drop all other filters.\ntrainable::Bool=false: if true, the wavelet filters are considered parameters, and can be updated using standard methods from Flux.jl.\nbias::Bool=false: if true, include an offset, initialized using init. Most likely to be used with trainable true.\ninit::function=Flux.glorot_normal: a function to initialize the bias, otherwise ignored.","category":"page"},{"location":"struct/#Parameters-passed-to-[ContinuousWavelets.jl](https://dsweber2.github.io/ContinuousWavelets.jl/dev/)","page":"scatteringTransform type","title":"Parameters passed to ContinuousWavelets.jl","text":"","category":"section"},{"location":"struct/","page":"scatteringTransform type","title":"scatteringTransform type","text":"scalingFactor, s, or Q::Real=8.0: the number of wavelets between the octaves 2^J and 2^J+1 (defaults to 8, which is most appropriate for music and other audio). Valid range is (0infty).\nβ::Real=4.0: As using exactly Q wavelets per octave leads to excessively many low-frequency wavelets, β varies the number of wavelets per octave, with larger values of β corresponding to fewer low frequency wavelets(see Wavelet Frequency Spacing for details). Valid range is (1infty), though around β=6 the spacing is approximately linear in frequency, rather than log-frequency, and begins to become concave after that.\nboundary::WaveletBoundary=SymBoundary(): The default boundary condition is SymBoundary(), implemented by appending a flipped version of the vector at the end to eliminate edge discontinuities. See Boundary Conditions for the other possibilities. \naveragingType::Average=Father(): determines whether or not to include the averaging function, and if so, what kind of averaging. The options are\nFather: use the averaging function that corresponds to the mother Wavelet.\nDirac: use the sinc function with the appropriate width.\nNoAve: don't average. this has one fewer filters than the other averagingTypes\naveragingLength::Int=4:  the number of wavelet octaves that are covered by the averaging, \nframeBound::Real=1: gives the total norm of the whole collection, corresponding to the upper frame bound; if you don't want to impose a particular bound, set frameBound<0.\nnormalization or p::Real=Inf: the p-norm preserved as the scale changes, so if we're scaling by s, normalization has value p, and the mother wavelet is psi, then the resulting wavelet is s^1ppsi(^t_s). The default scaling, Inf gives all the same maximum value in the frequency domain. Valid range is (0infty, though p1 isn't actually preserving a norm.","category":"page"},{"location":"subsampling/#Subsampling-Operators","page":"Subsampling Operators","title":"Subsampling Operators","text":"","category":"section"},{"location":"subsampling/","page":"Subsampling Operators","title":"Subsampling Operators","text":"RationPool\nRationPool(resSize::NTuple{N,Union{<:Integer,Rational{<:Integer}}}, k=2; nExtraDims=2, poolType=MeanPool) where {N}","category":"page"},{"location":"subsampling/#ScatteringTransform.RationPool","page":"Subsampling Operators","title":"ScatteringTransform.RationPool","text":"RationPool{A,B}\n\nAn extension of Flux's MaxPool and MeanPool to subsampling by rational amounts as well. Don't construct directly. Has fields r.m, which is the pooling operator as implemented in Flux, and r.resSize, which gives the subsampling rates, either as Integer, Rational, or tuples of these.\n\nIt works by first applying the given pooling operator, but with a step size of 1, and then keeping p out of q entries, where p is the numerator of the rational rate, and q is the denominator.\n\n\n\n\n\n","category":"type"},{"location":"subsampling/#ScatteringTransform.RationPool-Union{Tuple{Tuple{Vararg{Union{Rational, var\"#s28\"} where var\"#s28\"<:Integer, N}}}, Tuple{N}, Tuple{Tuple{Vararg{Union{Rational, var\"#s6\"} where var\"#s6\"<:Integer, N}}, Any}} where N","page":"Subsampling Operators","title":"ScatteringTransform.RationPool","text":"RationPool(resSize, k=2; nExtraDims=1, poolType = MeanPool)\n\nConstruct a RationPool instance, which is a slight extension of the Flux pooling methods to subsample at a rational rate resSize, which can vary by channel. For example, for a 2D input, resSize could be (2,3//2), 3//2 (equivalent to (3//2, 3//2)), or (5//3, 5//3).\n\nk is the window size of the pooling, and poolType is the type of pooling, either MaxPool or MeanPool. nExtraDims counts the number of dimensions uninvolved in the convolution; normally this is 2, as in (..., nChannels, nExamples). You can expect pooling to work for sizes up to 5 total dimensions.\n\n\n\n\n\n","category":"method"},{"location":"subsampling/#Subsampling-Utilities","page":"Subsampling Operators","title":"Subsampling Utilities","text":"","category":"section"},{"location":"subsampling/","page":"Subsampling Operators","title":"Subsampling Operators","text":"poolSize","category":"page"},{"location":"subsampling/#ScatteringTransform.poolSize","page":"Subsampling Operators","title":"ScatteringTransform.poolSize","text":"poolSize(k::RationPool, sizes)\npoolSize(k, sizs)\n\nReturn the number should we expect in the output with pooling rates k in each dimension (e.g. (3//2, 3//2) or RationPool((3//2,3//2))).\n\n\n\n\n\n","category":"function"},{"location":"pathLocs/#Path-Operations","page":"Path Operations","title":"Path Operations","text":"","category":"section"},{"location":"pathLocs/","page":"Path Operations","title":"Path Operations","text":"To make working with paths somewhat easier, in addition to indexing ScatteringOut by layer and then raw index, there is the pathLocs type:","category":"page"},{"location":"pathLocs/","page":"Path Operations","title":"Path Operations","text":"julia> using ScatteringTransform, Wavelets\n\njulia> St = scatteringTransform((1024,1,1),2)\nstFlux{2, Nd=1, filters=[15], σ = abs, batchSize = 1, normalize = true}\n\njulia> s = St(testfunction(1024, \"Doppler\"))\nScatteredOut{Array{Float32},3} 1 dim. OutputSizes:\n    (512, 1, 1)\n    (342, 15, 1)\n    (228, 14, 15, 1)\n\njulia> p = pathLocs(2, (3,5))\npathLocs{3}((nothing, nothing, (Colon(), 3, 5, Colon())))\n\njulia> s[p]\n228×1 Matrix{Float32}:\n 0.042854752\n 0.05448776\n ⋮\n 0.0009788324\n 0.0010495521\n","category":"page"},{"location":"pathLocs/","page":"Path Operations","title":"Path Operations","text":"p above for example, accesses the second layer path (3,5) (3 being the second layer index and 5 being the first layer index). The first entry specifies the layer, and the second specifies which entries in that layer.","category":"page"},{"location":"pathLocs/","page":"Path Operations","title":"Path Operations","text":"julia> p1 = pathLocs(2, (:,3))\npathLocs{3}((nothing, nothing, (Colon(), Colon(), 3, Colon())))\n\njulia> s[p1]\n228×14×1 Array{Float32, 3}:\n[:, :, 1] =\n 24.3279     0.0340069   …  0.000116684  0.000142872\n 24.3125     0.0458974      0.000125332  0.00016506\n  ⋮                      ⋱\n  0.0150998  0.00992407     2.98423f-5   8.26744f-5\n  0.0152391  0.0105978      2.61331f-5   7.9295f-5\n","category":"page"},{"location":"pathLocs/","page":"Path Operations","title":"Path Operations","text":"p1 grabs every path where the first layer index is 3.","category":"page"},{"location":"pathLocs/","page":"Path Operations","title":"Path Operations","text":"We can also grab multiple layers using a single path:","category":"page"},{"location":"pathLocs/","page":"Path Operations","title":"Path Operations","text":"julia> p2 = pathLocs(1, (5,), 2, (1,:))\npathLocs{3}((nothing, (Colon(), 5, Colon()), (Colon(), 1, Colon(), Colon())))\n\njulia> s[p2][1]\n342×1 Matrix{Float32}:\n 0.0057057445\n 0.007921134\n ⋮\n 0.0002874717\n 0.0003108125\n\njulia> s[p2][2]\n228×15×1 Array{Float32, 3}:\n[:, :, 1] =\n 0.0327152  8.44757    …  4.08167      3.19014\n 0.038269   8.65702       4.06725      3.17879\n ⋮                     ⋱\n 0.589429   0.0203722     0.000652602  0.000523428\n 0.590318   0.02058       0.000660961  0.000529933\n\njulia> p3 = pathLocs(1, s)\npathLocs{3}([(); (); … ; (); ();;;])","category":"page"},{"location":"pathLocs/","page":"Path Operations","title":"Path Operations","text":"pathLocs\nnonZeroPaths\ncomputeLoc","category":"page"},{"location":"pathLocs/#ScatteringTransform.pathLocs","page":"Path Operations","title":"ScatteringTransform.pathLocs","text":"struct pathLocs{m}\n    indices\nend\npathLocs(varargs...; m::Int=2, d::Int=1, exs=Colon())\n\nThe general constructor for path locs. The general pattern is alternating integers and tuples, with the integers corresponding to accessed layers, and the tuples to the paths accessed in that layer.\n\npathLocs(s::scattered)\n\nmake a pathLocs that accesses every location in the output.\n\n\n\n\n\n","category":"type"},{"location":"pathLocs/#ScatteringTransform.nonZeroPaths","page":"Path Operations","title":"ScatteringTransform.nonZeroPaths","text":"nonZeroPaths(sc; wholePath=true, allTogetherInOne=false)\n\nGiven a Scattered, return the pathLocs where the Scattered is nonzero. wholePath=true if it returns the whole path, and not just the specific location in the signal. For example, if only sc(pathLocs(1,(30,2))) is nonzero, if wholePath is true, then pathLocs(1,(2,)) will be returned while if wholePath is false, pathLocs(1,(30,2)) will be returned instead. if allTogetherInOne is false, then each location is returned separately, otherwise they are joined into a single pathLocs.\n\n\n\n\n\n","category":"function"},{"location":"pathLocs/#ScatteringTransform.computeLoc","page":"Path Operations","title":"ScatteringTransform.computeLoc","text":"p = computeLoc(loc, toRoll, st::stFlux)\n\ngiven a location loc in the flattened output toRoll, return a pathLocs describing that location in the rolled version\n\n\n\n\n\n","category":"function"},{"location":"plots/#Plotting-Scattering-Transforms","page":"Plots","title":"Plotting Scattering Transforms","text":"","category":"section"},{"location":"plots/","page":"Plots","title":"Plots","text":"Modules = [ScatteringPlots]","category":"page"},{"location":"plots/#ScatteringPlots.gifFirstLayer","page":"Plots","title":"ScatteringPlots.gifFirstLayer","text":"gifFirstLayer(origLoc, saveTo=\"tmp.gif\", fps = 2)\n\n\n\n\n\n","category":"function"},{"location":"plots/#ScatteringPlots.plotFirstLayer1D","page":"Plots","title":"ScatteringPlots.plotFirstLayer1D","text":"plotFirstLayer1D(j,origLoc,cline=:darkrainbow)\n\n\n\n\n\n","category":"function"},{"location":"plots/#ScatteringPlots.plotSecondLayer-Tuple{ScatteredOut, Any}","page":"Plots","title":"ScatteringPlots.plotSecondLayer","text":"plotSecondLayer(stw; title=\"Second Layer results\", xVals=-1, yVals=-1, logPower=true, toHeat=nothing, c=cgrad(:viridis, [0,.9]), threshold=0, linePalette=:greys, minLog=NaN, kwargs...)\n\nTODO fix the similarity of these names. xVals and yVals give the spacing of the grid, as it doesn't seem to be done correctly by default. xVals gives the distance from the left and the right as a tuple, while yVals gives the distance from the top and the bottom, also as a tuple. Default values are xVals = (.037, .852), yVals = (.056, .939), or if you have no title, use xVals = (.0105, .882), yVals = (.056, .939) If you have no colorbar, set xVals = (.0015, .997), yVals = (.002, .992) In the case that arbitrary space has been introduced, if you have a title, use xVals = (.037, .852), yVals = (.056, .939), or if you have no title, use xVals = (.0105, .882), yVals = (.056, .939)\n\n\n\n\n\n","category":"method"},{"location":"math/#Mathematical-Description","page":"Mathematical Description","title":"Mathematical Description","text":"","category":"section"},{"location":"math/","page":"Mathematical Description","title":"Mathematical Description","text":"Some math f(x)=3","category":"page"},{"location":"#ScatteringTransform.jl","page":"Home","title":"ScatteringTransform.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"A julia implementation of the scattering transform, which provides a prestructured alternative to a convolutional neural network. In a similar vein to a CNN, it alternates between continuous wavelet transforms, nonlinear function applications, and subsampling. This library is end-to-end differentiable and runs on the GPU; there is a companion package, ParallelScattering.jl that runs on parallelized CPUs.","category":"page"},{"location":"","page":"Home","title":"Home","text":"This is achieved by creating differentiable wavelet Fourier filters using FourierFilterFlux, which are then interspersed with Subsampling Operators modified from Flux.jl, and pointwise nonlinear functions (in practice, this means absolute value or ReLU).","category":"page"},{"location":"","page":"Home","title":"Home","text":"For a comparable package in python, see Kymatio.","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"#Basic-Example","page":"Home","title":"Basic Example","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"using ScatteringTransform, ScatteringPlots, Wavelets, Plots","category":"page"},{"location":"","page":"Home","title":"Home","text":"As an example signal, lets work with the doppler signal:","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Wavelets, Plots\nN = 2047\nf = testfunction(N, \"Doppler\")\nplot(f, legend=false, title=\"Doppler signal\")\nsavefig(\"rawDoppler.svg\"); #hide","category":"page"},{"location":"","page":"Home","title":"Home","text":"(Image: )","category":"page"},{"location":"","page":"Home","title":"Home","text":"First we need to make a scatteringTransform instance, which will create and store all of the necessary filters, subsampling operators, nonlinear functions, etc. The parameters are described in the scatteringTransform type. Since the Doppler signal is smooth, but with varying frequency, let's set the wavelet family cw=Morlet(π) specifies the mother wavelet to be a Morlet wavelet with mean frequency π, and frequency spacing β=2:","category":"page"},{"location":"","page":"Home","title":"Home","text":"using ScatteringTransform, ContinuousWavelets\nSt = scatteringTransform((N, 1, 1), 2, cw=Morlet(π), β=2, σ=abs)\nsf = St(f)","category":"page"},{"location":"","page":"Home","title":"Home","text":"The results sf are stored in the ScatteredOut type; for a two layer scattering transform, it has three output matrices (zeroth, first and second layers).","category":"page"},{"location":"#Zeroth-Layer","page":"Home","title":"Zeroth Layer","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The zeroth layer is simply a moving average of the original signal:","category":"page"},{"location":"","page":"Home","title":"Home","text":"plot(sf[0][:, 1, 1], title=\"Zeroth Layer\", legend=false)","category":"page"},{"location":"#First-Layer","page":"Home","title":"First Layer","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The first layer is the average of the absolute value of the scalogram:","category":"page"},{"location":"","page":"Home","title":"Home","text":"f1, f2, f3 = getMeanFreq(St) # the mean frequencies for the wavelets in each layer\nheatmap(1:size(sf[1], 1), f1[1:end-1], sf[1][:, :, 1]', xlabel=\"time index\", ylabel=\"Frequency (Hz)\", color=:viridis, title=\"First Layer\")","category":"page"},{"location":"#Second-Layer","page":"Home","title":"Second Layer","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The second layer is where the scattering transform begins to get more involved, and reflects both the frequency of the envelope surrounding the signal and the frequency of the signal itself. Visualizing this is also somewhat difficult, since each path in the second layer is indexed by a pair (s2,s1), where s2 is the frequency used for the second layer wavelet, and s1 is the frequency used for the first layer wavelet. To this end, lets make two gifs, the first with the first layer frequency varying with time:","category":"page"},{"location":"","page":"Home","title":"Home","text":"anim = Animation()\nfor jj = 1:length(f1)-1\n    toPlot = dropdims(sf[pathLocs(2, (:, jj))], dims=3)\n    heatmap(1:size(sf[2], 1), f2[1:end-1], toPlot', title=\"index=$(jj), first layer frequency=$(round(f1[jj],sigdigits=4))Hz\", xlabel=\"time\", ylabel=\"Frequency (Hz)\", c=cgrad(:viridis, scale=:exp))\n    frame(anim)\nend\ngif(anim, \"sliceByFirst.gif\", fps=1)","category":"page"},{"location":"","page":"Home","title":"Home","text":"By fixing the first layer frequency, we get the scalogram of a single line from the scalogram above. As the first layer frequency increases, the energy concentrates to the beginning of the signal and increased frequency, and generally decreases.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The second has the second layer frequency varying with time:","category":"page"},{"location":"","page":"Home","title":"Home","text":"anim = Animation()\nfor jj = 1:length(f2)-1\n    toPlot = dropdims(sf[pathLocs(2, (jj, :))], dims=3)\n    heatmap(1:size(sf[2], 1), f1[1:end-1], toPlot', title=\"index=$(jj), second layer frequency=$(round(f2[jj],sigdigits=4))Hz\", c=cgrad(:viridis, scale=:exp))\n    frame(anim)\nend\ngif(anim, \"sliceBySecond.gif\", fps=1)","category":"page"},{"location":"","page":"Home","title":"Home","text":"For any fixed second layer frequency, we get approximately the curve in the first layer scalogram, with different portions emphasized, and the overall mass decreasing as the frequency increases, corresponding to the decreasing amplitude of the envelope for the doppler signal. These plots can also be created using","category":"page"},{"location":"","page":"Home","title":"Home","text":"From the companion package ScatteringPlots.jl, we have the denser representation:","category":"page"},{"location":"","page":"Home","title":"Home","text":"using ScatteringPlots\nplotSecondLayer(sf, St)\nsavefig(\"second.png\") #hide","category":"page"},{"location":"","page":"Home","title":"Home","text":"(Image: )","category":"page"},{"location":"","page":"Home","title":"Home","text":"where the frequencies are along the axes, the heatmap gives the largest value across time for that path, and at each path is a small plot of the averaged timecourse.","category":"page"},{"location":"out/#ScatteredOut-type","page":"ScatteredOut type","title":"ScatteredOut type","text":"","category":"section"},{"location":"out/","page":"ScatteredOut type","title":"ScatteredOut type","text":"Scattered","category":"page"},{"location":"out/#ScatteringTransform.Scattered","page":"ScatteredOut type","title":"ScatteringTransform.Scattered","text":"Scattered{T,N}\n\nThe abstract parent type for ScatteredOut and ScatteredFull. T gives the element type for the matrices, while N gives one plus the depth of the scattering transform (so for two layers it is three).\n\n\n\n\n\n","category":"type"},{"location":"out/","page":"ScatteredOut type","title":"ScatteredOut type","text":"ScatteredOut","category":"page"},{"location":"out/#ScatteringTransform.ScatteredOut","page":"ScatteredOut type","title":"ScatteringTransform.ScatteredOut","text":"A simple wrapper for the results of the scattering transform. Its one field result contains a tuple of the results from each layer, in the order zero, one, two. Say we have an example s. You can access layer i by s[i], so s[0] gives the zeroth layer\n\n\n\n\n\n","category":"type"},{"location":"out/#ScatteredOut-Utilities","page":"ScatteredOut type","title":"ScatteredOut Utilities","text":"","category":"section"},{"location":"out/","page":"ScatteredOut type","title":"ScatteredOut type","text":"flatten\nroll\nimportantCoords","category":"page"},{"location":"out/#ScatteringTransform.flatten","page":"ScatteredOut type","title":"ScatteringTransform.flatten","text":"flatten(scatRes) -> output\n\ngiven scatRes, a scattered output or full, it produces a single vector containing the entire transform in order, i.e. the same format as output by thinSt.\n\n\n\n\n\n","category":"function"},{"location":"out/#ScatteringTransform.roll","page":"ScatteredOut type","title":"ScatteringTransform.roll","text":"roll(toRoll, st::stFlux)\n\nGiven a scattering transform st and an array toRoll that is NCoeffs×extraDims, \"roll\" up toRoll into a ScatteredOut.\n\n\n\n\n\n","category":"function"},{"location":"out/#ScatteringTransform.importantCoords","page":"ScatteredOut type","title":"ScatteringTransform.importantCoords","text":"importantCoords(scatRes)\n\ngiven a ScatteredOut scatRes, make a list that gives the largest value on each path.\n\n\n\n\n\n","category":"function"},{"location":"utils/#Utilities","page":"Utilities","title":"Utilities","text":"","category":"section"},{"location":"utils/","page":"Utilities","title":"Utilities","text":"ScatteringTransform.getMeanFreq\ngetWavelets\ndepth\nndims","category":"page"},{"location":"utils/#ContinuousWavelets.getMeanFreq","page":"Utilities","title":"ContinuousWavelets.getMeanFreq","text":"getMeanFreq(sc::stFlux{1}, δt=1000)\n\nGet a list of the mean frequencies for the filter bank in each layer. The averaging filter is last, and gives the mean frequency of the positive frequency only. Note that δt gives the sampling rate for the input only, and that it decreases at each subsequent layer at the rate implied by the subsampling in sc.\n\njulia> using ScatteringTransform\n\njulia> St = scatteringTransform((1024,1,1),2)\nstFlux{2, Nd=1, filters=[15], σ = abs, batchSize = 1, normalize = true}\n\njulia> f1, f2, f3 = getMeanFreq(St);\n\njulia> f1'\n1×16 adjoint(::Vector{Float64}) with eltype Float64:\n 7.70368  54.4302  78.7967  …  315.712  338.416  18.6697\njulia> f2'\n1×15 adjoint(::Vector{Float64}) with eltype Float64:\n 10.8253  64.1205  89.7788  …  296.729  317.265  22.1889\n\n\n\n\n\n","category":"function"},{"location":"utils/#ScatteringTransform.getWavelets","page":"Utilities","title":"ScatteringTransform.getWavelets","text":"getWavelets(sc::stFlux; spaceDomain=false) -> wave1, wave2, wave3, ...\n\nGet the wavelets used in each layer. If spaceDomain is true, then it will also convert the filters from the stored positive Fourier representation to a space version.\n\n\n\n\n\n","category":"function"},{"location":"utils/#ScatteringTransform.depth","page":"Utilities","title":"ScatteringTransform.depth","text":"depth(s::scatteringTransform{Dim,Depth})\n\ngiven a scattering transform, return the number of layers Depth.\n\n\n\n\n\n","category":"function"},{"location":"utils/#Base.ndims","page":"Utilities","title":"Base.ndims","text":"ndims(s::scatteringTransform{D})\n\ngiven a scattering transform s, return the number of layers Depth.\n\n\n\n\n\nndims(sct::Scattered)\n\nreturn the input dimension size (also given by sct.k)\n\n\n\n\n\nndims(r::MaxPool{N,M})\nndims(r::MeanPool{N,M})\n\nreturn the dimension N of the input signal\n\n\n\n\n\n","category":"function"},{"location":"utils/#Internal-Utilities","page":"Utilities","title":"Internal Utilities","text":"","category":"section"},{"location":"utils/","page":"Utilities","title":"Utilities","text":"batchOff\nScatteringTransform.normalize\nScatteringTransform.processArgs\nScatteringTransform.getParameters\nScatteringTransform.extractAddPadding","category":"page"},{"location":"utils/#ScatteringTransform.batchOff","page":"Utilities","title":"ScatteringTransform.batchOff","text":"batchOff(stack, x, batchSize)\n\ntransform x using stack, but where x and stack may have different batch sizes (the final dimension).\n\n\n\n\n\n","category":"function"},{"location":"utils/#ScatteringTransform.normalize","page":"Utilities","title":"ScatteringTransform.normalize","text":"normalize(x, Nd) -> normedX\n\nnormalize x over the dimensions Nd through ndims(x)-1. For example, if Nd=2, and x is 4D, then norm(normedX[:,:,:,j], 2) ≈ size(normedX,3).\n\n\n\n\n\n","category":"function"},{"location":"utils/#ScatteringTransform.processArgs","page":"Utilities","title":"ScatteringTransform.processArgs","text":"processArgs(m, varargs) -> listVargs\n\nGo from arguments given to the scattering transform constructor to those for the wavelet or frame transform. listVargs is a list of length m of one argument from each of vargs, with insufficiently long entries filled in by repeating the last value. For a list of these arguments, see the documentation for stFlux.\n\nExamples\n\njulia> using ContinuousWavelets, ScatteringTransform\n\njulia> varargs = ( :boundary      => PerBoundary(), :frameBound    => [1, 1], :normalization => (Inf, Inf))\n(:boundary => PerBoundary(), :frameBound => [1, 1], :normalization => (Inf, Inf))\n\njulia> varargs\n(:boundary => PerBoundary(), :frameBound => [1, 1], :normalization => (Inf, Inf))\n\njulia> listVargs = ScatteringTransform.processArgs(3,varargs)\n(Base.Pairs{Int64, Pair{Symbol}, Base.OneTo{Int64}, Tuple{Pair{Symbol, ContinuousWavelets.PerBoundary}, Pair{Symbol, Vector{Int64}}, Pair{Symbol, Tuple{Float64, Float64}}}}(1 => (:boundary => PerBoundary()), 2 => (:frameBound => [1, 1]), 3 => (:normalization => (Inf, Inf))), Base.Pairs{Int64, Pair{Symbol}, Base.OneTo{Int64}, Tuple{Pair{Symbol, ContinuousWavelets.PerBoundary}, Pair{Symbol, Vector{Int64}}, Pair{Symbol, Tuple{Float64, Float64}}}}(1 => (:boundary => PerBoundary()), 2 => (:frameBound => [1, 1]), 3 => (:normalization => (Inf, Inf))), Base.Pairs{Int64, Pair{Symbol}, Base.OneTo{Int64}, Tuple{Pair{Symbol, ContinuousWavelets.PerBoundary}, Pair{Symbol, Vector{Int64}}, Pair{Symbol, Tuple{Float64, Float64}}}}(1 => (:boundary => PerBoundary()), 2 => (:frameBound => [1, 1]), 3 => (:normalization => (Inf, Inf))))\n\njulia> listVargs[1]\npairs(::Tuple{Pair{Symbol, ContinuousWavelets.PerBoundary}, Pair{Symbol, Vector{Int64}}, Pair{Symbol, Tuple{Float64, Float64}}}) with 3 entries:\n  1 => :boundary=>PerBoundary()\n  2 => :frameBound=>[1, 1]\n  3 => :normalization=>(Inf, Inf)\n\njulia> listVargs[2]\npairs(::Tuple{Pair{Symbol, ContinuousWavelets.PerBoundary}, Pair{Symbol, Vector{Int64}}, Pair{Symbol, Tuple{Float64, Float64}}}) with 3 entries:\n  1 => :boundary=>PerBoundary()\n  2 => :frameBound=>[1, 1]\n  3 => :normalization=>(Inf, Inf)\n\njulia> listVargs[3]\npairs(::Tuple{Pair{Symbol, ContinuousWavelets.PerBoundary}, Pair{Symbol, Vector{Int64}}, Pair{Symbol, Tuple{Float64, Float64}}}) with 3 entries:\n  1 => :boundary=>PerBoundary()\n  2 => :frameBound=>[1, 1]\n  3 => :normalization=>(Inf, Inf)\n\n\n\n\n\n\n","category":"function"},{"location":"utils/#ScatteringTransform.getParameters","page":"Utilities","title":"ScatteringTransform.getParameters","text":"getParameters(st, s)\n\ngiven a scatteringTransform object and a symbol s representing a possible keyword, e.g. :Q, or :β, return the value for this transform. It may be in st.settings, or, if it is a default value, it is looked up.\n\n\n\n\n\n","category":"function"},{"location":"utils/#ScatteringTransform.extractAddPadding","page":"Utilities","title":"ScatteringTransform.extractAddPadding","text":"extractAddPadding(x, adr, chunkSize, N)\n\nFrom x, extract the examples adr in the last dimension, and make sure that it has a size of chunkSize, padding if there are too few examples (this is to make sure the batch size matches).\n\n\n\n\n\n","category":"function"}]
}
